/**
 * Any market indicator, they can be chained to form more complex data.
 */
export interface Indicator<I extends DataPoint | number, O> {
  /**
   * Set this to `true` if this indicator emits numbers. This is used for dynamic type
   * casting in runtime.
   * i.e: `O extends number`
   */
  readonly isNumeric: O extends number ? true : false;
  /**
   * Perform the conversion.
   * @param o The output generated by this indicator.
   */
  toNum?(o: O): number;
  /**
   * Compute the proper output for the given input and change the state.
   *
   * @param input The current input, which can be a OHLCV if the current
   * indicator is depended on the candle's data or a number if it's depended
   * on the output generated by another indicator.
   */
  next(input: I): O;
}

/**
 * An OHLCV data point.
 */
export interface DataPoint {
  readonly open: number;
  readonly high: number;
  readonly low: number;
  readonly close: number;
  readonly volume: number;
}
